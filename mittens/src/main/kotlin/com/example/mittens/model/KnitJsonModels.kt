package com.example.mittens.model

import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.core.type.TypeReference

/**
 * Data models for parsing knit.json dependency tree file generated by the Knit plugin.
 * This file contains the complete dependency injection graph that Knit uses at runtime.
 */

/**
 * Root structure of the knit.json file - a map of component class names to their dependency information
 */
typealias KnitJsonRoot = Map<String, KnitJsonComponent>

/**
 * Individual component entry in the knit.json file
 * @param parent List of parent classes this component extends/implements
 * @param injections Map of dependency injections with property names as keys
 * @param providers List of providers this component offers
 */
data class KnitJsonComponent(
    @JsonProperty("parent")
    val parent: List<String> = emptyList(),
    
    @JsonProperty("injections")
    val injections: Map<String, KnitInjection> = emptyMap(),
    
    @JsonProperty("providers")
    val providers: List<KnitJsonProvider> = emptyList()
) {
    /**
     * Get the simple class name from the full component path
     */
    fun getSimpleClassName(fullPath: String): String {
        return fullPath.substringAfterLast('/')
    }
    
    /**
     * Get the package name from the full component path
     */
    fun getPackageName(fullPath: String): String {
        if (!fullPath.contains('/')) return ""
        val packagePath = fullPath.substringBeforeLast('/')
        return packagePath.replace('/', '.')
    }
}

/**
 * Dependency injection information for a property
 * @param methodId The method ID that provides this dependency, includes scope info (e.g., "GLOBAL")
 */
data class KnitInjection(
    @JsonProperty("methodId")
    val methodId: String
) {
    /**
     * Extract the target type from the methodId
     * Format: "provider.class.method -> target.type (scope)"
     */
    fun getTargetType(): String {
        val arrowIndex = methodId.indexOf(" -> ")
        if (arrowIndex == -1) return ""
        
        val afterArrow = methodId.substring(arrowIndex + 4)
        val spaceIndex = afterArrow.indexOf(' ')
        return if (spaceIndex == -1) afterArrow else afterArrow.substring(0, spaceIndex)
    }
    
    /**
     * Extract the provider class from the methodId
     */
    fun getProviderClass(): String {
        val arrowIndex = methodId.indexOf(" -> ")
        if (arrowIndex == -1) return ""
        
        val beforeArrow = methodId.substring(0, arrowIndex)
        return beforeArrow.substringBeforeLast('.')
    }
    
    /**
     * Extract the scope from the methodId (e.g., "GLOBAL")
     */
    fun getScope(): String? {
        val openParen = methodId.lastIndexOf('(')
        val closeParen = methodId.lastIndexOf(')')
        return if (openParen != -1 && closeParen != -1 && closeParen > openParen) {
            methodId.substring(openParen + 1, closeParen)
        } else null
    }
    
    /**
     * Check if this is a singleton dependency based on scope
     */
    fun isSingleton(): Boolean {
        return getScope() == "GLOBAL"
    }
}

/**
 * Provider method information from knit.json
 * @param provider The provider method signature and return type
 * @param parameters Optional list of parameter types for the provider method
 */
data class KnitJsonProvider(
    @JsonProperty("provider")
    val provider: String,
    
    @JsonProperty("parameters")
    val parameters: List<String> = emptyList()
) {
    /**
     * Extract the method name from the provider string
     * Format: "class.method -> return.type" or "priority: N class.method -> return.type"
     */
    fun getMethodName(): String {
        val cleanProvider = if (provider.startsWith("priority:")) {
            provider.substringAfter(" ")
        } else provider
        
        val arrowIndex = cleanProvider.indexOf(" -> ")
        if (arrowIndex == -1) return ""
        
        val beforeArrow = cleanProvider.substring(0, arrowIndex)
        return beforeArrow.substringAfterLast('.')
    }
    
    /**
     * Extract the return type from the provider string
     */
    fun getReturnType(): String {
        val arrowIndex = provider.indexOf(" -> ")
        if (arrowIndex == -1) return ""
        
        return provider.substring(arrowIndex + 4)
    }
    
    /**
     * Extract the provider class from the provider string
     */
    fun getProviderClass(): String {
        val cleanProvider = if (provider.startsWith("priority:")) {
            provider.substringAfter(" ")
        } else provider
        
        val arrowIndex = cleanProvider.indexOf(" -> ")
        if (arrowIndex == -1) return ""
        
        val beforeArrow = cleanProvider.substring(0, arrowIndex)
        return beforeArrow.substringBeforeLast('.')
    }
    
    /**
     * Check if this provider has a priority
     */
    fun hasPriority(): Boolean {
        return provider.startsWith("priority:")
    }
    
    /**
     * Get the priority value if present
     */
    fun getPriority(): Int? {
        if (!hasPriority()) return null
        val afterLabel = provider.substringAfter("priority:").trimStart()
        val numberPart = buildString {
            for (ch in afterLabel) {
                if (ch.isDigit() || (isEmpty() && ch == '-')) {
                    append(ch)
                } else {
                    break
                }
            }
        }
        return numberPart.toIntOrNull()
    }
    
    /**
     * Check if this provider is generic (has type parameters)
     */
    fun isGeneric(): Boolean {
        return getReturnType().contains('<') || parameters.isNotEmpty()
    }
}

/**
 * Result of parsing a knit.json file
 */
data class KnitJsonParseResult(
    val success: Boolean,
    val components: KnitJsonRoot? = null,
    val errorMessage: String? = null,
    val sourceFile: String? = null
)

/**
 * Type reference for Jackson JSON parsing
 */
class KnitJsonTypeReference : TypeReference<KnitJsonRoot>()